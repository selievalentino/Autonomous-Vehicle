# Teshkerker
# Autonomous Vehicle
This is racing autonomous vehicle that can detect lanes, change direction, avoid obstacle, and detect trafic lights.
It is based on a small dc-motor powered RC car. Raspberry pi is being used as the master device and Romeo DF robot board as a slave device.
A Respberry pi camera is mounted on top of the vehicle to obratain the video feed,
The detected frames are then processed using several image processing techniques such as, Gaussian smoothing, Canny edge detection, hough transforms, and multi-class Otsu's thresholding.

When the vehicle is placed on the track and the camera is set to take image frames of the track continuously. The retrieved image frame is then passed on to the raspberry pi and converted to Grayscale. This is important because it makes it possible to detect and trace the white lines by their level of luminance. After this, a region of interest (ROI) is drawn on the Grayscale image as seen by the pi camera. Then an Otsu's threshold is applied to the frame to filter out white pixels of the lane line only. Once we have a frame containing only the black road and the white lanes, we draw small vertical blocks on the ROI (indicated by the red box in figure 7) and calculate the number of white pixels in each block with respect to the dark pixels. The boxes containing large number of white pixels are assumed to overlap with the white lines and, therefore, their position with respect to the frame is calculated and saved in a dynamic array. From this, by applying the canny edge detection algorithm, the outlines of the white pixels are accurately drawn, separating the white lines from the track. Now that the white lanes are correctly identified and their position within the frame is known, we find the lane center and calibrate the position of the car with respect to it. To do this, the vehicle has to be placed exactly at the center of the lane. If so, then it means that the center of the image frame captured by the camera is the same as the position of the vehicle inside the lane. From here, we take the center of the frame and reposition it so it overlaps with the lane center calculated earlier. Once this is done, using a function we wrote, that calculates the deviation of the vehicle from the lane center and determine its position with respect to the closest side line, we keep tabs on the position of the vehicle at all times. Finally, based on the position of the vehicle navigation commands are sent to the DFrduino, which in turn sends commands to the wheels. 
